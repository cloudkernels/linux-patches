From 0341bd4b256b5e9ecbd00b9dba0532d3f4681526 Mon Sep 17 00:00:00 2001
From: Charalampos Mainas <cmainas@nubificus.co.uk>
Date: Tue, 28 Feb 2023 14:52:30 +0000
Subject: [PATCH 2/2] Export vma allocation related functions

Hedge guests use kernel allocated memory, which is obtained by vmalloc.
On the other hand KVM expects a userspace memory and proccess to run
guests. In order to avoid any changes in KVM code we the guest
memory will be mapped to a real address space.

As a result vm_area_alloc and vm_area_free functions need to be
exported, THese are the functions which will be used to create the new
mappings for the guest memory. Moreover mm_alloc is needed to create
a new struct mm and not to use an existing one. Additionally
arch_pick_mmap_layout is necessary to make get_unmapped_area work in
the new mm.

Signed-off-by: Anastassios Nanos <ananos@nubificus.co.uk>
Signed-off-by: Konstantinos Papazafeiropoulos <kostis@nubificus.co.uk>
Signed-off-by: Charalampos Mainas <cmainas@nubificus.co.uk>
Signed-off-by: Stratos Psomadakis <psomas@nubificus.co.uk>
---
 arch/x86/mm/mmap.c | 1 +
 kernel/fork.c      | 3 +++
 mm/mmap.c          | 2 ++
 mm/util.c          | 1 +
 4 files changed, 7 insertions(+)

diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
index aae9a933d..b7701a084 100644
--- a/arch/x86/mm/mmap.c
+++ b/arch/x86/mm/mmap.c
@@ -147,6 +147,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 			rlim_stack);
 #endif
 }
+EXPORT_SYMBOL(arch_pick_mmap_layout);
 
 unsigned long get_mmap_base(int is_legacy)
 {
diff --git a/kernel/fork.c b/kernel/fork.c
index 9180f4416..760c06f80 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -350,6 +350,7 @@ struct vm_area_struct *vm_area_alloc(struct mm_struct *mm)
 		vma_init(vma, mm);
 	return vma;
 }
+EXPORT_SYMBOL(vm_area_alloc);
 
 struct vm_area_struct *vm_area_dup(struct vm_area_struct *orig)
 {
@@ -366,6 +367,7 @@ void vm_area_free(struct vm_area_struct *vma)
 {
 	kmem_cache_free(vm_area_cachep, vma);
 }
+EXPORT_SYMBOL(vm_area_free);
 
 static void account_kernel_stack(struct task_struct *tsk, int account)
 {
@@ -1067,6 +1069,7 @@ struct mm_struct *mm_alloc(void)
 	memset(mm, 0, sizeof(*mm));
 	return mm_init(mm, current, current_user_ns());
 }
+EXPORT_SYMBOL(mm_alloc);
 
 static inline void __mmput(struct mm_struct *mm)
 {
diff --git a/mm/mmap.c b/mm/mmap.c
index 514cc19c5..3e2c4149c 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2845,6 +2845,7 @@ int do_munmap(struct mm_struct *mm, unsigned long start, size_t len,
 {
 	return __do_munmap(mm, start, len, uf, false);
 }
+EXPORT_SYMBOL(do_munmap);
 
 static int __vm_munmap(unsigned long start, size_t len, bool downgrade)
 {
@@ -3200,6 +3201,7 @@ int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 	return 0;
 }
+EXPORT_SYMBOL(insert_vm_struct);
 
 /*
  * Copy the vma structure to a new location in the same mm,
diff --git a/mm/util.c b/mm/util.c
index ab358c64b..ea44c0b3b 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -398,6 +398,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 	}
 }
+EXPORT_SYMBOL(arch_pick_mmap_layout);
 #elif defined(CONFIG_MMU) && !defined(HAVE_ARCH_PICK_MMAP_LAYOUT)
 void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 {
-- 
2.25.1

